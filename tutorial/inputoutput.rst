.. _tut-io:

****************
Оролт, гаралт
****************

Програмын гаралтыг хэд хэдэн аргаар дүрслэх боломжтой; Өгөгдлийг хүнд ойлгогдох
хэлбэрээр хэвлэж болно, эсвэл ирэйдүүд хэрэглэхээр файл руу хадгалж болно. Энэ
бүлгээр бид эдгээр аргуудын заримтай нь дэлгэрэнгүй танилцах болно.


.. _tut-formatting:

Гоёмсог гаралтын хэлбэржүүлэлт
==============================

Өмнөх бүлгүүдээр бид *expression statements* болон түлхүүр үг 'print' ийг ашиглан 
утга хэвлэхийг үзсэн билээ.  (Гурав дахь арга нь файлын ``write()`` функцыг
ашиглах арга юм; стандарт гаралтын файл нь ``sys.stdout`` аар заагддаг. Илүү
дэлгэрэнгүй мэдээллийг Үндсэн сангийн лавлахаас харна уу.)

.. index:: module: string

Ихэнхдээ та нар энгийн хоосон зайгаар тусгаарлагдсан хэлбэрээр гаралтаа
хэвлэхээс илүү олон төрлөөр хэвлэхийг хүсдэг. Энд гаралтыг хэвжүүлэх хоёр 
төрлийн арга байдаг; Эхний арга нь тухайн стрингээ боловсруулахад өөрөө бүгдийг
хийх; стринг хуваах болон нилүүлэх опературуудыг ашиглан өөрийн хүсэж байсан
хэлбэртэй стрингийг үүсгэж болно. Стандарт модуль :mod:`string` нь стрингийг 
тухайн өгөгдсөн баганд багтаахад зориулсан хэрэгцээтэй функцуудыг агуулдаг;
Удахгүй үүний талаар бага зэрэг тайлбарлах болно. Хоёр дахь арга нь 
:meth:`str.format` функцыг ашиглах юм.

Мэдээж бидэнд нэг асуулт урган гарч ирж байна, Хэрхэн хувьсагчийн утгуудыг стринг
төрөл рүү хөрвүүлэх вэ? гэдэг. Азаар путон ямар нэг утгыг стринг руу хөрвүүлэх 
дараах аргатай: Тухайн төрлийн өгөгдөлд :func:`repr` эсвэл :func:`str` функцуудыг 
дамжуулах.

:func:`str` функц нь ихэнхдээ хүн уншихад зориулагдсан утгыг буцаахад
зориулсан байдаг бол :func:`repr` функц нь ихэнхдээ компьютерийн эмхэтгэгчид
уншигдахад зориулагдсан утгыг дүрслэхэд зориулагдсан байдаг (эсвэл
:exc:`SyntaxError` буюу бичиглэлийн алдаа гарах үед хэрэглэх). Хүний
хэрэгцээнд зориулсан тусгайлсан дүрслэл байхгүй объектын хувьд, :func:`str` нь
:func:`repr` тай ижил утгыг буцаах болно. Тоон төрөл болон өгөгдлийн бүтцийн
жагсаалт, толь гэх мэт ихэнх төрлүүдийн эдгээр функцууд нь ижил утга буцаадаг.
Харин бутархай тоо, стринг гэх мэт төрлүүдийн дээрх функцууд нь өөр өөр утга 
буцаадаг.

Жишээ::

   >>> s = 'Hello, world.'
   >>> str(s)
   'Hello, world.'
   >>> repr(s)
   "'Hello, world.'"
   >>> str(1.0/7.0)
   '0.142857142857'
   >>> repr(1.0/7.0)
   '0.14285714285714285'
   >>> x = 10 * 3.25
   >>> y = 200 * 200
   >>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
   >>> print s
   The value of x is 32.5, and y is 40000...
   >>> # The repr() of a string adds string quotes and backslashes:
   ... hello = 'hello, world\n'
   >>> hellos = repr(hello)
   >>> print hellos
   'hello, world\n'
   >>> # The argument to repr() may be any Python object:
   ... repr((x, y, ('spam', 'eggs')))
   "(32.5, 40000, ('spam', 'eggs'))"

Куб болон квадрад утгуудыг хүснэгтээр хэвлэх 2 төрлийн арга::

   >>> for x in range(1, 11):
   ...     print repr(x).rjust(2), repr(x*x).rjust(3),
   ...     # Дээрх мөр таслал тэмдэгттэй байгааг анхаарна уу!
   ...     print repr(x*x*x).rjust(4)
   ...
    1   1    1
    2   4    8
    3   9   27
    4  16   64
    5  25  125
    6  36  216
    7  49  343
    8  64  512
    9  81  729
   10 100 1000

   >>> for x in range(1,11):
   ...     print '{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x)
   ...
    1   1    1
    2   4    8
    3   9   27
    4  16   64
    5  25  125
    6  36  216
    7  49  343
    8  64  512
    9  81  729
   10 100 1000

(Эхний жишээн дээр багана бүрийн хоорондох нэг хоосон зай нь :keyword:`print` ээр
нэмэгдсэн юм: Энэ нь үргэлж өөрийнхөө аргументуудад хоосон зай нэмдэг юм.)

Дээрх жишээгээр стринг объектын :meth:`rjust` функцыг хэрхэн ашиглахыг үзүүллээ,
энэ нь тухайн стрингийг өгөгдсөн урттай талбарт баруун шахаж талд нь байрлуулдаг ба
зүүн талд үлдсэн сул зайг нь хоосон зайгаар орлуулдаг. Мөн :meth:`ljust` ба 
:meth:`center` гэх төстөй функцууд байдаг. Эдгээр функцууд нь өгөгдсөн
стрингийн утгыг өөрчилдөггүй ба харин шинээр стринг үүсгэдэг. Хэрвээ тухайн
стринг нь хэтэрхий урт байвал өгөгдсөн уртад нь тааруулж тухайн стрингийг
тасалдаггүй, ямарч өөрчлөлт хийлгүй тухайн стрингийг хэвээр нь буцаадаг; Энэ нь 
магадгүй чиний баганы форматыг эвдэж болох ч энэ нь тухайн утгыг тасалсанаас 
илүү дээр байдаг. (Хэрвээ чи үнэхээр тухайн утгыг өгөдсөн уртаар таслах хэрэгтэй 
бол ``x.ljust(n)[:n]`` операторыг ашиглаж болно.)

Мөн өшөө :meth:`zfill` гэдэг функц байгаа, энэ нь тоон утгатай стрингийн зүүн 
талд тэгийг нэмдэг.  Энэхүү функц нь тухайн тоон стрингийн нэмэх, хасах
тэмдгийг ойлгож чадна::

   >>> '12'.zfill(5)
   '00012'
   >>> '-3.14'.zfill(7)
   '-003.14'
   >>> '3.14159265359'.zfill(5)
   '3.14159265359'

:meth:`str.format` функцыг хэрэглэх энгийн жишээ нь дараах хэлбэртэй байна::

   >>> print 'We are the {} who say "{}!"'.format('knights', 'Ni')
   We are the knights who say "Ni!"

Хашилтын тэмдтгүүдийг формат талбар гэж нэрлэдэг ба эдгээр нь :meth:`~str.format`
функцаар дамжиж ирсэн объектын утгаар солигддог. Хашилтан дотор байгаа тоонууд
нь :meth:`~str.format` функцаар дамжиж ирсэн объектуудын байрлалыг заадаг. ::

   >>> print '{0} and {1}'.format('spam', 'eggs')
   spam and eggs
   >>> print '{1} and {0}'.format('spam', 'eggs')
   eggs and spam

Хэрвээ :meth:`~str.format` функцын нэрлэсэн аргументыг хэрэглэсэн байвал, 
тэдгээрийн утга нь тухайн хашилтанд нэрлэсэн түлхүүр үгээр солигддог. ::

   >>> print 'This {food} is {adjective}.'.format(
   ...       food='spam', adjective='absolutely horrible')
   This spam is absolutely horrible.

Байрлалын болон түлхүүр үгтэй аргументуудыг дураараа хослуулан ашиглаж болно::

   >>> print 'The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
   ...                                                    other='Georg')
   The story of Bill, Manfred, and Georg.

``'!s'`` (хэрэгжилт нь :func:`str`) ба ``'!r'`` (хэрэгжилт нь :func:`repr`)
операторууд нь тухайн стрингийг хэлбэржүүлэхээс өмнө хэрэглэгдэж болно. ::

   >>> import math
   >>> print 'The value of PI is approximately {}.'.format(math.pi)
   The value of PI is approximately 3.14159265359.
   >>> print 'The value of PI is approximately {!r}.'.format(math.pi)
   The value of PI is approximately 3.141592653589793.

``':'`` болон хэлбэр тодорхойлогч нь талбарын нэрийн араас орж болно. Энэ нь 
тухайн үндсэн боломжоос илүү утгыг хэлбэржүүлэх боломж олгоно. Дараах жишээ нь
дээр пи тооны бутархайн орныг 3 оронгоор тасалсан байна. ::

   >>> import math
   >>> print 'The value of PI is approximately {0:.3f}.'.format(math.pi)
   The value of PI is approximately 3.142.

``':'`` тэмдэгийн араас бүхэл тоон утга дамжуулсанаар тухайн талбарын нийт урт
тухайн тооноос багагүй байхаар хэлбэржүүлнэ. Энэ нь хүснэгт хэлбэрээр өгөгдлийг
дүрслэхэд хялбар байх болно. ::

   >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
   >>> for name, phone in table.items():
   ...     print '{0:10} ==> {1:10d}'.format(name, phone)
   ...
   Jack       ==>       4098
   Dcab       ==>       7678
   Sjoerd     ==>       4127

Хэрвээ хуваахыг хүсэггүй байгаа урт хэмжээтэй стрингийг хэлбэржүүлэх хэрэгтэй
байгаа бол байрлалаар аргумент дамжуулахаас илүү түлхүүр үг ашиглан
аргументаа дамжуулбал дээр байх болно. Үүнийг хэрэгжүүлэхийн тулд толь утга
арументаар дамжуулан дөрвөлжин хаалт ``'[]'`` ашиглан тэдгээрийн утгуудад
хандах байдлаар хэрэгжүүлнэ ::

   >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
   >>> print ('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
   ...        'Dcab: {0[Dcab]:d}'.format(table))
   Jack: 4098; Sjoerd: 4127; Dcab: 8637678

Үүнийг бас өөрөөр тухайн table хувьсагчийг '**' тэмдэглэлийг ашиглан түлхүүр үг
аргумент хэлбэрээр дамжуулж болно. ::

   >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
   >>> print 'Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table)
   Jack: 4098; Sjoerd: 4127; Dcab: 8637678

Үүнийг шинэ үндсэн функц :func':`vars` хослуулан ашиглавал илүү хэрэгцээтэй
байх болно, энэ нь бүх дотоод хувьсагчдыг агуулсан толийг буцаадаг.

Стринг хэлбэржүүлэх :meth:`str.format` функцын талаар дэлгэрэнгүйг, :ref:`formatstrings`
хэсгээс харж болно.


Хуучин стринг хэлбэржүүлэлт
---------------------------

Мөн ``%`` оператор нь стрингийг хэлбэржүүлэхэд хэрэглэгддэг. Энэ нь :cfunc:`sprintf` 
функцтай адил зүүн талын аргументаас эхлэн өгөгдсөн хэлбэржүүлэлтийн дагуу
хэлбүүржүүлж эхэлдэг, ба тухайн хэлбэржсэн стрингийг буцаадаг. Жишээ нь ::

   >>> import math
   >>> print 'The value of PI is approximately %5.3f.' % math.pi
   The value of PI is approximately 3.142.

:meth:`str.format` нь одоохондоо шинэ байгаа бөгөөд, ихэнх пайтон код нь ``%``
операторыг одоо хүртэл хэрэглэсээр байна. Гэхдээ хуучин стринг хэлбэржүүлэх 
арга нь яваандаа пайтон хэлнээс хасагдах учир, :meth:`str.format` функцыг 
хэрэглэж байсан нь дээр.

Илүү дэлгэрэнгүй мэдээллийг :ref:`string-formatting` хэсгээс сонирхож болно.


.. _tut-files:

Файлаас уншиж, бичих
=========================

.. index::
   builtin: open
   object: file

:func:`open` функц нь файл төрлийн объектыг буцаах ба, arguments: ``open(filename, mode)``
гэсэн 2 аргумент ихэнхдээ хэрэглэгддэг.

::

   >>> f = open('/tmp/workfile', 'w')
   >>> print f
   <open file '/tmp/workfile', mode 'w' at 80a0960>

Эхнийх нь файлын нэрийг агуулсан стринг төрлийн аргумент юм.   Хоёр дахь аргумент нь
тухайн файл хэрхэн хэрэглэгдэхийг илэрхийлсэн хэдэн тэмдэгтийг агуулсан стринг төрлийн 
хувьсагч байна.  *mode* нь ``'r'`` гэсэн утгатай байж болох ба тэр үед тухайн
файлаас зөвхөн уншиж болно, ``'w'`` нь зөвхөн бичих (өмнө нь үүссэн файл байвал доторх нь 
устах болно), ``'a'`` нь файлын агуулга дээр нэмэхээр нээдэг; тухайн файл руу бичсэн 
утгууд нь автоматаар файлын төгсгөлд нэмэгдэнэ.  ``'r+'`` нь файлыг унших болон бичихээр
нээдэг. *mode* нь дурын (заавал тодорхойлох шаардлагагүй) аргумент юм; хэрвээ тухайн аргумент 
тодорхойлогдоогүй байвал ``'r'`` гэсэн анхны утгыг авна.

Виндовс үйлдлийн систем дээр, нэмэлт ``'b'`` горим нь файлыг хоёртын горимд
нээдэг, Тиймээс ``'rb'``, ``'wb'``, ``'r+b'`` гэх мэт нэмэлт горимууд байдаг.
Виндовс дээрх пайтоны хувьд текст болон хоёртын файлууд ялгаатай байдаг; өгөгдөл 
унших болон бичих үед мөрийн төгсгөл тусгай тэмдэгт далд байдлаар өөрчлөгддөг.
Энэхүү далд өөрчлөлтийн үр дүн ASCII төрлийн текст файлуудын хувьд зүгээр байдаг
ба, Харин :file:`JPEG`, :file:`EXE` гэх мэт хоёртын файлын хувьд эвдрэл
үүсгэдэг. Ийм төрлийн файлаас унших болон бичих үед хоёртын горимыг ашиглахдаа
болгоомжтой байгаарай.  Юникс төрлийн системүүд дээр ``'b'`` горимыг файл нээх 
горим дээр нэмэхэд ямар нэг гэмтэл гардаггүй, тиймээс үүнийг ямар нэг платформ
хамааралгүй бүх төрлийн хоёртын файлын хувьд ашиглаж болно.


.. _tut-filemethods:

Файл объектын функцууд
-----------------------

Энэ хэсгийн ихэнх жишээн дээр гарж байгаа ``f`` файлыг өмнө аль хэдийн үүссэн 
файл гэж үзэж байгааг анхаараарай.

файлын агуулгыг уншихийн тулд, ``f.read(size)`` гэх байдлаар дуудна, энэ нь 
тодорхой тооны өгөгдлийг уншаад, стринг хэлбэрээр утгыг буцаана.  *size* нь 
дурын тоон төрлийн аргумент.  *size* нь тодохойлогдоогүй эсвэл хасах утгатай 
байх үед, файлын бүх агуулгыг уншаад буцаагдана. Хэрвээ чиний унших гэж байгаа 
файл машиний чинь санах ойноос хэд дахин их хэмжээтэй байвал асуудал үүснэ.
Өөрөөр хэлбэл хамгийн их *хэмжээ* тэй байтууд уншигдаад дараа нь буцаагдана.
Хэрвээ файлын төгсгөлд хүрсэн бол, ``f.read()`` функц нь хоосон стринг (``""``)
утгыг буцаана. ::

   >>> f.read()
   'This is the entire file.\n'
   >>> f.read()
   ''

``f.readline()`` функц нь тухайн файлаас нэг мөрийг уншдаг; шинэ мөр тэмдэгт
(``\n``) нь тухайн стрингийн төгсгөлд байдаг, ба зөвхөн тухайн файл нь шинэ мөр
тэмдэгтээр төсгөөгүйгээс бусад үед сүүлийн мөрийн шинэ мөр тэмдэгт нь хасагддаг.
Энэ нь буцаж байгаа утгыг нэгэн утгатай болгодог; Хэрвээ ``f.readline()`` нь 
хоосон стринг буцааж байвал, файлын төгсгөлд хүрсэн гэсэн үг, тухайн үед хоосон 
мөр нь ``'\n'`` тэмдэгтээр илэрхийлэгдэнэ, ямар ч стринг нь зөвхөн нэг шинэ
мөр тусгай тэмдэгтийг агуулдаг.   ::

   >>> f.readline()
   'This is the first line of the file.\n'
   >>> f.readline()
   'Second line of the file\n'
   >>> f.readline()
   ''

``f.readlines()`` функц нь тухайн файл дахь бүх мөрүүдийг буцаана. Хэрвээ
дурын параметр *sizehint* өгөгдвөл, тухайн хэмжээний файлыг байтыг файлаас
унших ба тухайн файлын хэмжээнээс их өгөдвөл зөвхөн тухайн файлын өгөгдлийг
буцаана. Ихэнхдээ энэ нь том хэмжээний файлыг уншихад тухайн файлыг бүтнээр нь 
санах ойд ачаалах боломжгүй үед үр хэрэглэхэд үр дүнтэй байдаг. Зөвхөн 
гүйцэд мөрүүд буцаж ирэх болно. ::

   >>> f.readlines()
   ['This is the first line of the file.\n', 'Second line of the file\n']

Файлын мөрүүдийг унших өөр арга нь файл объектыг давталданд ашиглах арга юм.
Энэ нь санах ойд хэмнэлттэй, хурдан, энгийн кодоор хийх боломжтой::

   >>> for line in f:
           print line,

   This is the first line of the file.
   Second line of the file

Энэхүү арга нь маш энгийн боловч бусад өөр файлын удирдлагуудаар хангагдаагүй 
байдаг.  Дээрх хоёр арга нь мөрүүдийг буффэрлэхдээ өөрөөр хийдэг ба тэдгээрийг
хослуулан хэрэглэж болохгүй.

``f.write(string)``  *стринг* ийн утгыг файл руу бичих ба, ``None`` утга
буцаана.   ::

   >>> f.write('This is a test\n')

Стрингээс өөр төрлийн утгыг файл руу бичихийн тулд эхлээд түүнийг стринг рүү
хөрвүүлсэн байх хэрэгтэй::

   >>> value = ('the answer', 42)
   >>> s = str(value)
   >>> f.write(s)

``f.tell()`` нь файлын идэвхтэй байрлалыг илэрхийлсэн бүхэл тоон утгыг буцаах
ба, тэрхүү тоо нь файлын эхлэлээс байрлал хүртэл байтын хэмжээ байна. Файлын 
идэвхтэй байрлалыг өөрчлөхийн тулд ``f.seek(offset, from_what)`` функцыг 
ашиглана.  Тухайн байрлал нь заагдсан байрлал дээр  *offset*  хэмжээг нэмсэнээр 
бодогдоно; заагдсан байрлал нь *from_what* аргументаар заагдана.  *from_what* ийн
утга 0 нь файлын эхлэлийг заана, 1 нь тухайн идэвхтэй байрлал, 2 нь тухайн файлын
төгсгөлийн байрлал юм.  *from_what* нь тодорхойлогдохгүй байж болох ба анхны утга нь
0 байна, өөрөөр хэлбэл файлын эхлэлийг зааж байдаг. ::

   >>> f = open('/tmp/workfile', 'r+')
   >>> f.write('0123456789abcdef')
   >>> f.seek(5)     # Go to the 6th byte in the file
   >>> f.read(1)
   '5'
   >>> f.seek(-3, 2) # Go to the 3rd byte before the end
   >>> f.read(1)
   'd'

Файл дээр ажиллаж дууссан бол ``f.close()`` функцыг файлыг хааж, системж эзэлж 
байсан нөөцөө чөлөөлөхийн тулд дуудах хэрэгтэй.  ``f.close()`` функцыг
дуудасны дараа, файлын объектыг ашиглахыг завдсан үйлдэл дээр алдаа автоматаар
гарах болно. ::

   >>> f.close()
   >>> f.read()
   Traceback (most recent call last):
     File "<stdin>", line 1, in ?
   ValueError: I/O operation on closed file

Файл объекттай хамт :keyword:`with` түлхүүр үгийг ашиглах нь сайн арга юм. 
Ингэснээр тухайн файл дээр хийж буй иж бүрдэл үйлдэл дуусахад тухайн файл
хаагддаг, тухайн үйлдэлүүд хийгдэж байх үед алдаа гарсан ч гэсэн тухайн файл
зөв хаагдах болно.  Энэ нь :keyword:`try`\ -\ :keyword:`finally` блоктой адил
боловч илүү богино байдлаар бичигддэг::

    >>> with open('/tmp/workfile', 'r') as f:
    ...     read_data = f.read()
    >>> f.closed
    True

Файл объект нь зарим нэмэлт функцуудтай, :meth:`~file.isatty`, :meth:`~file.truncate`
гэх мэт өргөн хэрэглэгддэггүй функцууд байна; Файл объектын талаар дэлгэрэнгүй
мэлээллийг стандарт сангийн лавлах хэсгээс харж болно.


.. _tut-pickle:

Модуль :mod:`pickle`
------------------------

.. index:: module: pickle

Стринг төрлийн объектуудыг файл руу бичих, уншихад хялбар. :meth:`read` функц
нь зөвхөн стринг төрлийн утга буцаадаг учир, тоон төрлийг файлаас уншихад, тухайн 
уншсан утгыг стрингээс тоон төрөл рүү хөрвүүлдэг :func:`int` функцаар дамжуулах
зэрэг бага зэрэг ажиллагаа хэрэгтэй байдаг.  Мөн түүнчлэн жагсаалт, толь, классын
төл гэх мэт төвөгтэй нийлмэл хэлбэртэй өгөгдлүүдийг файлд хадгалах шаардлагатай
байдаг.

Эдгээр нийлмэл өгөгдлийн төрлүүдийг файлд хадгалын тулд хэрэглэгчидээр байнга
өөрсдөөр нь код бичүүлгүйн тулд пайтон нь стандарт модуль :mod:`pickle` ээр
хангагдсан байдаг. Энэ нь ямар ч төрлийн пайтоны өгөгдлийн төрлийг (зарим
төрлийн пайтоны кодыг ч гэсэн болно!) авч чадах гайхалтай модуль юм. Үүнийг 
ашиглан объектыг стринг рүү хөрвүүлэхийг :dfn:`pickling` гэж нэрлэдэг ба, эсрэгээр
нь стрингээс пайтоны объект үүсгэхийг :dfn:`unpickling` гэж нэрлэдэг. Pickling болон 
unpickling ийн хооронд үүссэн стрингийг файлд өгөгдөл хэлбэрээр хадгалж, эсвэл 
тусдаа хоолын хоёр машины хооронд сүлжээгээр дамжуулна болно.

Хэрвээ ``x`` гэдэг объект байгаа ба мөн бичихээр нээгдсэн ``f`` байгаа бол 
тухайн объектыг файл руу хадгалах код нь ердөө нэг мөр код болох юм::

   pickle.dump(x, f)

буцаагаад тухайн ``f`` файлаас тухайн объектыг дараах байдлаар үүсгэнэ::

   x = pickle.load(f)

(дээрх аргаас өөр, олон объектыг пикл хийх, файлаас өөр зүйл рүү пикл хийх гэх
мэт өөр хэлбэрүүд байж болох ба пайтоны стандарт сангийн баримтын :mod:`pickle` 
модулийн хэсгээс дэлгэрэнгүй үзээрэй.)

:mod:`pickle` нь хадгалагдаж болох, өөр програмуудад дахин ашиглагдаж болох,
эсвэл тухайн програмд ирэйдүүд хэрэглэгдэж болох зэрэг объектыг үүсгэх
пайтоны стандарт арга юм. Техникийн нэр томъёонд үүнийг :dfn:`persistent` 
объект гэдэг.  :mod:`pickle` модуль маш өргөн хэрэглэгддэг учир, пайтонд
зориулан өргөтгөл, шинэ модуль бичдэг олон пайтон хөгжүүлэгчид матрикс гэх 
мэт шинэ төрлийн өгөгдлийн төрлийг зөв хэлбэрээр пикл болон анпикл хийдэг 
болгохын төлөө санаа тавин ажиллаж байна.



